前端采用 bootstrap、jquery，后端采用 springboot、rabbitmq、redis，数据库 mysql。

主要分为两个模块

登录模块、秒杀模块。



登录模块使用了两次md5加密，第一次加密是用户密码+盐进行md5，防止密码在网络上明文传播，第二次加密是客户端加密过的密码+随机盐进行md5，防止因为数据库被黑用户密码泄漏。

用户登录成功后，会生成一个属于用户的token存储在redis中，并将该token存储在cookie中，用户只要携带该token就可以判定已经登录。



秒杀模块主要流程：

1、获取商品库存

2、判断商品库存是否大于0

3、判断用户是否秒杀过商品（根据用户 id 和商品 id 判断订单表是否存在订单）

4、减库存

5、生成订单和订单详情



### 第一阶段优化 建立数据库索引

1、查看全部商品有按照价格排序功能，体现在数据库就是 `order by price`，对商品价格一列建立索引，这样数据库选取数据后就不用继续在内存排序或者外部排序

2、根据用户 id 和商品 id 获取订单是秒杀中最常使用的查询语句，所以建立 `(userId, goodId)` 联合索引，因为没有其他单独根据 userId 或者 goodId 的订单详情查询语句，所以联合索引的顺序暂时不用考虑。



### 第二阶段优化 缓存对象及数据

1、在系统初始化时，将参与秒杀的商品库存加载到redis，如果收到请求，直接在redis预减库存。减少了查询库存，减库存两次数据库的访问。

2、用户成功秒杀后，将生成的订单缓存在 redis 中，这样在判断用户是否秒杀过当前商品时则可以直接查询 redis。



### 第三阶段优化 异步下单三、重复下单

将成功秒杀的用户请求发送至消息队列，由消费者从消息队列中异步消费消息，如果成功，写入订单和订单详情。



经过三次优化，秒杀的主要流程为：

1、系统初始化，将商品库存加载到 redis

2、秒杀开始，在 redis 中预减库存，库存不足直接返回，否则进入下一步

3、在 redis 判断用户是否存在订单，存在返回，不存在进入下一步

4、将秒杀请求发送至消息队列，返回客户端正在排队中

5、消费者从消息队列消费请求，生成订单，减少库存

6、客户端轮询查看是否秒杀成功



### 其他优化

1、设置商品库存售完标志（hashmap, key = goodId, value=flag），如果商品售完直接返回，不用再查询 redis

2、隐藏秒杀地址，点击秒杀时，触发函数生成随机的path写入redis，key为 `userId + goodId`。通过带path的url作为秒杀地址。key为 `userId + goodId`。主要过程：点击秒杀按钮 -> 生成随机path -> 跳转到带path的秒杀地址 -> 进行秒杀，无论秒杀成功还是失败，都要删除或者修改redis中的path，防止抓包抓到秒杀地址

3、对接口进行限流，防止系统崩溃，因为 google RateLimiter 只支持单机限流，所以模仿其实现一个简单的分布式限流器





### 遇到的问题及思考

**一、刚开始只缓存了秒杀对象，反而使 qps 下降，使用top命令查看，发现居然是mysql服务占用大量cpu资源**

原因：缓存了秒杀对象，用户下单后会进行减库存，可是在缓存中的对象库存没有改变，导致大量用户秒杀成功，并且一直进行向数据库减库存、写订单操作。

**二、超买**

在没使用redis前出现超买，主要解决方法，在减库存时判断库存是否大于0

```mysql
UPDATE crush_goods SET stock_count = stock_count-1 WHERE goods_id = #{goodId} and stock_count > 0
```

**三、重复下单**

建立用户id 和 商品 id 的联合索引，同时也是唯一索引

**四、优化后如果用户已经秒杀成功，可是还没有将生成的订单缓存至redis，这时在有库存的时候用户重新秒杀是否会成功**

不会，因为前面用户重复订单已经建立唯一索引，如果相同的用户和秒杀商品会使写入失败，进而使此次秒杀失败



### 其他

rabbitmq 的可靠性投递

redis 一主二从三哨兵